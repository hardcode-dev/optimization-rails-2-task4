# Шаг 1 настройка метрик

Newrelic и Scout активно используются у нас в компании так что их установка прошла гладко, скайлайт уже стоял так что я добавил только ключ, залил конечно в репозиторий но он не секьюрный а поднимать тут Dotfiles или другую систему доставки ENV вне скоупа задания

Я давно хотел посмотреть yabeda-prometheus-grafanа и вот момент настал,

    поставил все через brew
    сменил графане порт на 3001 в /usr/local/etc/grafana/grafana.ini
    добавил запуск прометеуса в Procfile
    сделал config/prometheus.yml
    немного помучался с yabeda он то ругался на 2 подключения то не показывал /metrics помогло перечитать документацию по всем гемам внимательно
    поставил дашборд ябеды в графану (спасибо гугл) https://grafana.com/grafana/dashboards/11668

Чудо но это все заработало жаль графиков из коробки немного но зато получил общее понимание по PromQL типа `sum(rate(rails_requests_total[1m])) by (status)`

Rack-mini-profiler и rails-panel мы уже ставили ранее, проблем не возникло

#Шаг 2 local_production
Я заметил что по коду проекта довольно много вызовов Rails.env.production? и решил для частоты эксперимента оставить env production
Но добавить переменную окружения LOCAL_PRODUCTION которая будет немного менять настройки

Для этого я создал 2 файла с конфигами и переопределил production.rb

    Rails.application.configure do

      if ENV['LOCAL_PRODUCTION']
        Config::LocalProductionConfig.call(config)
      else
        Config::ProductionConfig.call(config)
      end
    end

#Шаг 3 анализ
При переходах по вебсайту я заметил что очень много запросов осуществуляется с главной страницы, мне стало интересно попрофилировать именно ее, ведь главная - это лицо прилоежния и она должна быть самой быстрой

ab -n 1000 http://127.0.0.1:3000/
     
    Percentage of the requests served within a certain time (ms)
      50%     81
      66%     91
      75%    102
      80%    109
      90%    129
      95%    195
      98%    216
      99%    240
     100%    240 (longest request) 
     
     
Судя по Newrelic довольно много времени сьедает рендеринг styles и single_story     
Как можно заметить по коду styles кэширется на 8 часов довольно агресивно так что ее мы оставляем - это нагрузка 1 раз после рестарта

Еще крутой отчет у личной мной очень любимого скаута 
https://scoutapm.com/shares/30ae2948-6e4d-438e-a8fb-d0bde053aae0
Добавил ruby-prof as Rack::Midleware

26.06%	занимает рендеринг single_story и больше всего от него 84% это 	ActionView::Helpers::RenderingHelper#render

#шаг4 кэширование

Для промежуточных тестирований буду использовать 100 замеров в аб для ускорения филбек лупа
ab -n 1000 http://127.0.0.1:3000/

Я выделил внутренние блоки которые имеет смысл кэшировать - 

1. блок юзера, в качестве ключа я взял story_user_#{story.user.id}_#{story.user.updated_at}
2. блок организации story_organization_#{story.organization&.slug}_#{@organization_article_index}_#{story.organization&.updated_at}
3. целиком весь партиал single_story_#{story.id}_#{story.updated_at}_#{story.user.updated_at}_#{story.organization&.updated_at} вроде бы это должно покрыть и изменения в организациях и комментарии и лайки 


#шаг 5 анализ результатов

Тут для полной уверенности что нет внешних факторов я решил запустить на 1000 проб


ab -n 1000 http://127.0.0.1:3000/

    Percentage of the requests served within a certain time (ms)
      50%     52
      66%     55
      75%     58
      80%     61
      90%     94
      95%    102
      98%    120
      99%    140
     100%    198 (longest request)
     
Налицо сокращение 95 персентиля почти в 2 раза, 99 персентиля на 40%    
Mean average request time  уменьшилось с 92.500Ms до  59.093ms что я считаю отличным результатом
Визуально контент не изменился, однако следует попросить меинтейнеров тщательно проверить пул реквест на предмет ключей кэширования так как в силу незнания специфики проекта я мог солидно ошибиться

Сравнение ньюрелика 

До https://ibb.co/HnmDcXd
После https://ibb.co/khNjdCf